# 섹션3 객체 지향 원리 적용

# 새로운 할인 정책 개발

## 새로운 할인 정책 확장

- 악덕 기획자: 서비스 오픈 직전에 할인 정책을 지금처럼 고정 금액 할인이 아니라 좀 더 합리적인 주문 금액당 할인하는 정률 할인으로 변경하고 싶음
    - 예를 들어 기존 정책은 VIP 가 10000원을 주문하든 20000원을 주문하든 항 상 1000원을 할인하는데, 이번에 새로 나온 정책은 10% 로 지정해두면 고객이 10000원을 할인해주고, 20000원 주문시에 2000원 할인을 해주는 방식
- 순진 개발자: 처음부터 고정 금액은 아니였음
- 악덕기획자: 에자일 소프트 웨어 개발에 보면 → 계획을 따르기 보다 변화에 대응
- 순진 개발자: 이미 객체지향 원칙을 지켰기 때문에 가능

<aside>
💡 객체 지향 원칙을 잘 준수했는지 확인해보자. 이번에는 주문 금액의 % 할인을 해주는 새로운 정률 할인 정책을 추가해보자

</aside>

## RateDiscountPolicy 추가

- OrderServiceImple → DiscountPolicy(interface)

# 새로운 할인 정책 적용과 문제점

## 방금 추가한 할인 정책을 적용해보자

## 할인 정책을 어플리케이션에 적용해보자

- 기존에 사용했던 코드에서 새로운 정책 구현체로 변경해줬음

```java
    // private final DiscountPolicy discountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
```

- **할인 정책을 변경하려면 클라이언트인 OrderServiceImpl 코드를 고쳐야 한다**

## 문제점 발견

- 우리는 역활과 구현을 충실하게 분리했다 → OK
- 다형성도 활용하고, 인터페이스와 구현 객체를 분리했다 → OK
- OCP DIP 같은 객체 지향 설계 원칙을 준수했다
    - **그렇게 보이지만 사실이 아님**
- DIP 주문 서비스 클라이언트( `OrderServiceImpl`) 는 `DiscountPolicy` 인터페이스에 의존하면서 DIP 를 지킨건 같은데?
    - 클래스의 의존 관계를 분석해보자 → 추상(인터페이스) 뿐만 아니라 **구체(구현) 클래스에도 의존** 하고 있다
        - 추상(interface)의존: DiscountPolicy
        - 구체(구현) 클래스: FixDiscountPolicy RateDiscountPolicy
- OCP: 변경하지 않고 확장 할수있다고 했는데?
    - **지금 코드는 기능을 확장해서 변경하면 클라이언트 코드에 영향을 준다**
    - **따라서 OCP 를 위반한다**

## 왜 클라이언트 코드를 변경해야 할까?

- 클래스 다이어그램으로 의존관계를 분석해보자

## 기대했던 의존관계

- OrderServiceImpl → DiscountPolicy (FixDiscountPolicy RateDiscountPolicy)

## 실제 의존관계

- OrderServiceImpl → DiscountPolicy
    - (FixDiscountPolicy RateDiscountPolicy)
- 인터페이스만 의존하는줄 알았지만 실제 구현체도 의존하고 있음
    - 실제 코드를 보면 의존하고 있음
- DIP 위반!

## 정책 변경

- FixDiscountPolicy  에서 RateDiscountPolicy 로 변경하는 순간 OrderServiceImple 의 소스 코드도 변경해야 한다
- OCP 위반

## 어떻게 문제를 해결할 수 있을까?

- 클라이언트 코드인 OrderServiceImpl 은 DiscountPolicy 의 인터페이스 뿐만 아니라 구체 클래스도 함께 의존해야 한다
- 그래서 구체 클래스를 변경할 때 클라이언트 코

# 관심사의 분리

# AppConfig 리팩토링

# 새로운 구조와 할인 정책 적용

# 전체 흐름 정리

# 좋은 객체 지향 설계의 5가지 원칙 적용

# IoC DI 그리고 컨테이너

# 스프링으로 전환하기