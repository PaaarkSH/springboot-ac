# 섹션 2 스프링 핵심 원리 이해1 - 예제 만들기

# 프로젝트 생성

<aside>
💡 목표: 순수한 자바로 스프링 개발 → 실제 요구사항에서 대처가 가능한가?

</aside>

## 팁

- 인텔리제이에서 gradle 빌드 설정을 intelij 로 변경
    - gradle 통해서 스프링 부트 실행하는것 보다 intelij 가 직접 jvm 을 실행시키는게 빠르다 하심
        - 돌아가는 구조는 gradle 이 jvm 을 실행하는 과정과 크게 다를것은 없음

# 비즈니스 요구사항과 설계

## 회원

- 회원을 가입하고 조회할 수 있음
- 회원은 일반과 VIP 두가지 등급이 있음
- 회원 데이터는 자체 DB 를 구축 할 수 있고, 외부 시스템과 연동할 수 있음(미확정)

## 주문과 할인 정책

- 회원은 상품을 주문 할 수 있음
- 회원 등급에 따라 할인 정책을 적용 할 수 있음
- 할인 정책은 모든 VIP 는 1000원을 할인해주는 고정 금액 할인은 적용해 달라
    - 나중에 변경 될 수 있음
- 할인 정책은 변경 가능성이 높다
    - 회사 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다
    - 최악의 경우 할인을 적용하지 않을 수 도 있다(미확정)

## 정리

- 요구사항을 보면 회원 데이터, 할인 정책 같은 부분은 지금 결정하기 어려운 부분
- 그렇다고 이런 정책이 결정될 때 까지 개발을 무기한 기다릴 수 없음
- 인터페이스를 만들고 구현체를 언제든지 갈아끼울 수 있도록 설계해야함

> “참고” 프로젝트 환경설정을 편리하게 하려고 스프링 부트를 사용한 것
지금은 스프링 없는 순수한 자바로만 개발을 진행한다는 점을 기억하자
> 

# 회사 도메인 설계

## 회원 도메인 요구사항

- 회원을 가입하고 조회할 수 있다
- 회원은 일반과 VIP 두 가지 등급이 있다
- 회원 데이터는 자체 db 를 구축 할 수 있고, 외부 시스템과 연동 할 수 있다

## 회원 도메인 협력 관계

- 클라이언트 → 회원 서비스(회원가입, 회원조회) → 회원 저장소 (메모리, db, 외부시스템 연동)
- **개발자 뿐만 아닌 기획자도 볼수있는 구조**
- 회원 저장소
    - 회원 데이터에 접근하는 계층을 새로 만듬
    - 역활 구현(구현체를 선택하면 됨)
        - 메모리 회원 저장소
            - 메모리이기 때문에 운영용으로는 못씀
        - db 회원 저장소
        - 외부 시스템 연동 회원 저장소

## 회원 클래스 다이어그램

- `MemberService` ← `MemberServiceImpl` → `MemberRepository`
- `MemberService`: interface
- `MemberServiceImpl`
    - 구현체
- `MemberRepository`: interface, 회원 저장소
    - `MemoryMemberRepository`
    - `DbMemberRepository`
- 실제 서버를 구동하지 않고 클래스들만 분석해서 볼 수 있는 그림
    - 그런데 구현체들이 동적으로 결정되는것들, 즉 서버가 뜰 때 new 결정을 하는 것들 때문에 클래스 다이어그램 만으로 보고 판단하기 어려움
    - 그래서 객체 다이어그램이라는게 있어야 함

## 회원 객체 다이어그램

<aside>
💡 메모리간의 참조들이 어떻게 되는지

</aside>

- 클라이언트 → 회원 서비스 → 메모리 회원 저장소
- 회원 서비스: `MemberServiceImpl`

# 회원 도메인 개발

<aside>
💡 본격적인 개발

</aside>

# 회원 도메인 실행과 테스트

<aside>
💡 지난 시간에 만든 코드들이 정상 동작하는지 테스트

</aside>

- 클래스 다이어그램의 코드들은 전부 구현
- 회원 객체 다이어그램이 실제 동작하는지 확인

## TroubleShooting

- 강사님은 일반적인 코드에서 테스트 코드 라이브러리를 사용하는 코드를 보여주셨는데 일반적인 설정으로 해당 코드를 돌려보면 오류가 발생했음
- 이유를 찾아보니 testImplementation 은 test 에서만 라이브러리를 가져오는 코드였어서 오류가 날 수 밖에 없었음
- dependency 를 해당 코드처럼 수정해줘야만 돌아감

```java
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'org.junit.jupiter:junit-jupiter:5.8.1'
    implementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

## 회원 도메인 설계의 문제점

- 이 코드의 설계상 문제점은 무엇일까요?
- 다른 저장소로 변경할 때 OCP 원칙을 준수할 까요?
- DIP 를 잘 지키고 있을까요?
- **의존관계가 인터페이스 뿐만 아니라 구현까지 모두 의존하는 문제점이 있음**
    - **주문까지 만들고나서 문제점과 해결 방안을 설명**
- 구현체는 인터페이스를 의존하고있음
    - 하지만 실제 할당하는 부분은 구현체에 의존됨
    - 추상화에도 의존하고 구현체에도 의존됨

```java
 private final MemberRepository memberRepository = new MemoryMemberRepository();
 // 만약 MemoryMemberRepository 말고 다른 구현체를 써야 한다면??
```

# 주문과 할인 도메인 설계

## 주문과 할인 정책

- 회원은 상품을 주문할 수 있다
- 회원 등급에 따라 할인 정책을 적용할 수 있다
- 할인 정책은 모든 VIP 는 1000원 할인해주는 고정 금액 할인을 적용해 달라
    - 나중에 변경 가능
- 할인 정책은 변경 가능성이 높다
- 회사의 기본 할인 정책은 아직 정하지 않았고, 오픈 직전까지 고민을 미루고 싶다
- 최악의 경우 할인을 적용하지 않을 수 있다

## 주문 도메인 협력 역활 책임

### 클라이언트

- 주문 생성
    - 회원 id
    - 상품명
    - 상품 가격

### 주문 서비스 역활

### 회원 저장소 역활(회원 조회)

### 할인 정책 역활(할인 적용)

- 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청
- 회원 조회: 할인을 위해서는 회원 등급이 필요하다. 그래서 서비스는 회원 저장소에서 회원을 조회한다
- 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임한다
- 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다
    - 자세하게 하면 복잡해져서 단순히 주문 결과 객체를 만들어서 클라이언트에 보내는것 까지만
    - 실제 DB 에 저장하는 과정은 생략

## 여기서 협력 역활 책임에 대해서

- 협력: 객체들끼리 메세지를 주고 받으며 상호작용을 하는것
- 역활: 구현체가 아닌 인터페이스로서 역활만 수행하는것
- 책임: 객체가 협력하기 위해 수행하는 로직
    - 객체가 변경됬을때 수정사항이 많아지고 적어짐을 책임분배를 해줘야함

## 주문 도메인 전체

- **클라이언트**
- **주문 서비스 역활**
    - 주문 서비스 구현체
- 회원 조회
    - **회원 서비스 역활**
        - 메모리 회원 저장소
        - DB 저장소
- 할인 적용
    - **할인 정책 역활**
        - 정액 할인 정책
            - 절대 가격 할인
        - 정률 할인 정책
            - 비율에 따른 가격 할인
        
- **역활과 구현을 분리**해서 자유롭게 구현 객체를 조립할 수 있게 설계했다. 덕분에 회원 저장소는 물론이고, 할인 정책도 유연하게 변경 할 수 있다

## 주문 도메인 클래스 다이어그램

- OrderService: interface
- OrderServiceImpl
    - MemberRepository: interface
        - MemoryMemberRepository
        - DbMemberRepository
    - DiscountPolicy: interface
        - FixDiscountPolicy
        - RateDiscountPolicy

## 주문 도메인 객체 다이어그램1

<aside>
💡 클라이언트 → 주문 서비스 구현체 → 메모리 회원 저장소, 정액 할인 정책

</aside>

- 회원을 메모리에서 조회하고, 정액 할인 정책(고정 금액)을 지원해도 주문 서비스를 변경하지 않아도 된다
- **역활들의 협력관계를 그대로 재사용 가능**
    - 메모리에서 DB 로 바뀌고 정액에서 정률 서비스로 변경해도 주문 서비스 구현체를 변경할 필요가 없음
    - 조용호님이 객체지향의 사실과 오해 라는 책이 이걸 하나만 가지고 쓴 책
        - 이게 핵심인데 읽어보면 도움됨
        - 

## 주문 도메인 객체 다이어그램2

<aside>
💡 클라이언트 → 주문 서비스 구현체 → DB 회원 저장소, 정률 할인 정책

</aside>

- 회원을 메모리가 아닌 실제 DB 에서 조회하고, 정률 할인 정책(주문 금액에 따라 % 할인)을 지원해도 주문 서비스를 변경하지 않아도 된다
- 협력관계를 그대로 재사용 할 수 있다

# 주문과 할인 도메인 개발

# 주문과 할인 도메인 실행과 테스트