# 섹션 1. 객체 지향 설계와 스프링

# 이야기 - 자바 진영의 추운 겨울과 스프링의 탄생

<aside>
💡 시대적 배경을 알면 공부하기 편해서 만드셨음

</aside>

## EJB

### 설명

- Enterprise Java Beans
    - 스프링 + JPA 의 역활을 하던 라이브러리
    - ORM 기능도 내장하고 있었음
- 당시에는 오픈소스를 사용하지 않는 분위기였음
- 당시에 금융권에서 사용을 많이 사용하는 분위기였음
- 당시에 확립되지 않은 라이브러리를 사용하는건 금융권들에서 문제가 많았음

### 문제점

- 문제는 가격이 비쌌음
    - 서버들의 가격도 문제가 많았음
- 익히기 어렵고 복잡하고 느림
    - 기능이 아무리 많아도 단순하고 편해야함
- 너무 개발하는방법이 복잡해서 이전 순수한 자바 코딩으로 돌아가자는 말이 나옴
    - 그때 등장한 개념이 **POJO**
    - pojo(plain old java object): 간단하고 오래된 방식의 자바
- ORM 이 있었긴 했지만 Entity Bean 의 기술 수준 자체가 낮았음
    - join 같은게 잘 안되는 수준
- 그래서 오픈소스를 개발함 → 스프링

## 스프링

- EJB 컨테이너 대체
- 단순함의 승리
- 현재 사실상 표준

## 하이버네이트

- EJB 엔티티 Bean 기술을 대체
- JPA(java persistence API) 새로운 표준 정의
- 나중에는 EJB 의 ORM 을 사용하지 않고 하이버네이트만 사용함
- EJB 엔티티 Bean → 하이버네이트 → JPA
    - EJB 엔티티빈을 만들던 개발자들이 하이버네이트 개발자인 게빈 킹을 데리고 와서 만든게 JPA
- JPA 는 인터페이스 여서 구현체를 필요로함
    - 하이버네이트
    - EclipseLink
    - 기타 등등
- **대부분 JPA 하이버네이트를 사용한다 보면 됨**

## 오픈소스의 단점

- 오픈소스들의 단점은 용어나 기술들에 대한 정제가 잘 안된다는 단점이 있긴함
- 그래도 JPA 라는 표준을 만들어내기는 했음
    - 실무에서 필요하던 기술에 표준이 생기면서 실용성 없는 부분들은 검열함

## 스프링 역사

- 지금 현대 사회에 있어서 스프링과 JPA 는 둘다 너무 중요한 기술
- 로드 존슨이란 개발자가 책을 출간함
- EJB 의 문제점 지적
- EJB 없이도 고품질의 확장가능한 어플리케이션 개발이 가능함을 보여주고 3만 라인 이상의 기술 코드를 보여줌
    - 여기 안에 우리가 아는 Bean 팩토리, AOP Application Context POJO DI IOC 등등 개념이 들어감
- 책이 유명해지고 책의 예제 코드를 프로젝트에 사용
    - 오픈소스를 쓰는게 아니라 책의 예제코드가 오픈소스가 되어버린것
- 책 출간 이후 유겐 휠러 + 얀 카로프가 로드 존슨한테 오픈소스 프로젝트 제안
- 스프링의 핵심 코드는 유겐 휠러가 지금도 개발
- J2EE (EBJ) 라는 겨울을 넘어 새로운 시작이라는 뜻으로 지음

### 릴리즈

- 스프링은 세팅을 하거나 war 파일을 배포하는 과정이 너무 복잡했음
- 당시에 웹 프레임워크가 서버를 내장해서 개발하는게 유행이였음
- 

# 스프링이란?

## 스프링 생태계

- 특정 하나가 아니라 여러가지 기술의 집합이라 볼 수 있음

### 필수

- 스프링
- 스프링 부트

### 선택

- 스프링 데이터
    - RDB 나 NoSQL 이나 어차피 CRUD 는 비슷하기 때문에 이런것들을 편리하게 사용하는거
    - JPA
- 스프링 세션
    - 세션 기능을 편리하게 사용 가능
- 스프링 시큐리티
    - 보안 관련
- 스프링 Rest Docs
    - API 문서화 라이브러리
- 스프링 배치
    - 보통 실무에서 1000만건의 처리를 해야될 경우가 있을떄 이것은 끊어서 처리하는것에 특화된 기술
- 스프링 클라우드
    - 클라우드 기술에 특화
- 등등
    - [spring.io](http://spring.io) 사이트에 가보면 종류 설명이 많음
    - **하지만 핵심은 스프링 프레임워크**
        - 이 강의의 초점

## 스프링 프레임워크

- 핵심기술
    - 스프링 DI 컨테이너, AOP, 이벤트, 기타
- 웹 기술
    - 스프링 MVC
    - 스프링 WebFlux
- 데이터 접근 기술
    - 트랜잭션
    - JDBC
    - ORM
    - XML 지원
- 기술 통합
    - 캐시, 이메일, 원격, 스케줄링
- 테스트
    - 스프링 기반 테스트 지원
- 언어
    - 코틀린, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

## 스프링 부트

- **스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용**
- 단독으로 실핼할 수 있는 스프링 어플리케이션을 쉽게 생성
- Tomcat 같은 웹서버를 내장해서 별도의 웹서버 설치를 안해도 됨
    - 예전에는 스프링 빌드를 위해서 절차가 복잡했음
    - 스프링 빌드 + 톰캣 서버에 별도의 설치
    - 지금의 스프링 부트는 빌드와 서버를 띄우는것을 바로 제공
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
    - 예전에는 스프링을 구성하기 위한 starter 라이브러리들이 너무 많았음
- 스프링과 서드파티 라이브러리 자동 구성
    - 버전 별 호환성이 외부 라이브러리랑 잘 안맞았었음
    - 이제 이후부터는 스프링이 외부 라이브러리를 맞춰서 알아서 사용하게 해줌
- 메트릭, 상태확인, 외부 구석 같은 프로덕션 준비 기능 제공
    - 운영환경에서 모니터링이 너무 중요함
    - 스프링부트가 어느정도 기본 지원을 해줌
- 관례에 의한 간결한 설정
    - 만약 스프링 부트가 없었다면 스프링 + 톰캣 + mysql 등등 설치하는데 시간을 다 소비했을것

### 오해

- **스프링 부트는 스프링과 별도로 사용하는게 아님**
- 스프링 부트는 방금까지 보여준 기능들을 편리하게 사용할 수 있도록 제공
- 결과적으로 말하자면 껍데기 기능만 있는것
    - 껍데기 기능이라 하기에 기능이 편리하기도 하고 추가적인 기능들도 있긴함
- 정리하자만 스프링 부트는 스프링 기술을 편리하게 사용하게 해주는 기능이지 이 자체만으로 뭔가를 할 수 있는건 아님

## 스프링 단어?

- 스프링이라는 단어가 애매함
    - 공식문서에서부터 애매거나 문맥에 따라 다르다고 명시함
- 스프링이라는 단어는 문맥에 따라 다르게 사용됨
    - 스프링 DI 컨테이너 기술
    - 스프링 프레임워크
    - 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

## 스프링은 왜 만들었는가?

- 해당 얘기를 하기전에 스프링의 핵심 개념이 뭔지 알아야함

## 핵심개념

<aside>
💡 이 기술은 왜 만들었는가?
이 기술의 핵심 컨셉은?

</aside>

- 기술은 단순할 수록 좋음
- 지금의 큰 생태계도 로드 존슨의 3만줄 코드에서 시작함

## 스프링의 핵심 개념, 컨셉?

- 웹 어플리케이션 만들고 db 접근을 편리하게 하는 기술?
    - 사실 현실적으로 맞는 말이긴 함 ㅋㅋ
- 전자 정부 프레임워크?
- 웹 서버도 자동으로 띄워주고?
- 클라우드, 마리크로 서비스?
- **이것은 결국 결과물**

## 스프링의 진짜 핵심

- 스프링은 자바 언어 기반의 프레임워크
    - 자바 언어의 가장 큰 특징이 객체 지향
- 자바 언어의 가장 큰 특징 - **객체지향언어**
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 **좋은 객체 지향** 어플리케이션을 개발할 수 있게 도와주는 프레임워크
- 당시에 EJB 를 사용하면 상속받고 하면서 굉장히 지저분하게 EJB 에 의존적으로 개발을 하게됨
    - 이렇게 되면 문제가 객체 지향의 장점이 없어짐
    - EJB 에 의존적이게 되버림
    - 그래서 순수 객체지향으로 돌아가자는 POJO 라는 단어도 나옴
    - 그래서 DI IOC 컨테이너가 나옴
        - 그게 대단한게 아니라 그냥 객체지향을 잘 할수있게 도와주는 도구

강사님이 아시는 사람중 스프링이 싫다는 사람이 있었음

- 이유는 스프링을 사용하게 되면 스프링에 종속적으로 코딩할 수 밖에 없다 했음
- 사실 이런거는 스프링을 사용한다기 보다 스프링의 기능을 사용한다는게 맞는말
- 스프링의 본질을 알면 얼마나 스프링이 객체 지향 프로그래밍을 지향하는 지 알수있음

# 좋은 객체 지향 프로그래밍이란?

## 객체 지향 특징

- 추상화
- 캡슐화
- 상속
- **다형성**

## 객체 지향 프로그래밍

- 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 **‘객체’**들의 **모임**으로 파악하고자 하는것.
각각의 객체는 메세지를 주고받고, 데이터를 처리할 수 있다(**협력**)
    - 객체들의 모임
    - 메시지를 주고받고 데이터를 처리할 수 있다
        - 객체들끼리 협력을 한다는 의미
- 객체 지향 프로그래밍은 프로그램을 **유연**하고 **변경**이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용됨

## 유연하고 변경이 용이?

- 레고 블럭을 조립하듯
- 키보드 마우스 갈아 끼우듯
- 컴퓨터 부품 갈아 끼우듯
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
- **이것이 바로 다형성**

## 다형성의 실세계 비유

- 실세계와 객체 지향을 1:1로 매칭X
- 그래도 실세계의 비유로 이해하기에는 좋음
- **역활**과 **구현**으로 세상을 구분

## 운전자 - 자동차

- 자동차 역활
    - k3
    - 아반떼
    - 테슬라
- 운전자 역활
- 운전자는 k3 를 운전하다가 아반떼를 운전해도 가능함
    - 왜 그럴까?
    - 자동차 역활의 인터페이스에 따라서 자동차를 구현했기 때문
    - 운전자는 자동차 인터페이스에만 의존하고있음
- 자동차의 인터페이스를 통해 구현체를 분리한 이유가 뭘까?
    - 운전자의 편의를 위해서
    - 자동차의 역활만 유지하고 있으면 운전자를 변경할 필요가 없음
        - 다른 대상으로 변환이 가능
        - 운전자에게 영향을 주지 않고 자동차만 변경이 가능
- 이것들이 가능한 이유가 **역활과 구현**으로 세상을 구분했기 때문에 가능
    - 자동차 역활을 여러 개 구현할 수 있는게 중요한게 아님
    - 새로운 자동차가 나와도 클라이언트는 변경사항이 없다는것

## 공연 무대

### 로미오와 줄리엣 공연

- 로미오 역활과 줄리엣 역활을 어떤 배우든 대체가 가능해야함
    - 공연은 되어야함
    - **이게 바로 유연하고 변경에 용이함**

## 다형성의 실세계 비유

- 운전자 - 자동차
- 공연 무대
- 키보드 마우스 세상의 표준 인터페이스
- 정렬 알고리즘
- 할인 정책 로직

## 역활과 구현을 분리

- **역활**과 **구현**으로 구분하면 세상이 **단순**해지고 **유연**해지며 **변경**도 편리해짐

### 장점

- **클라이언트**는 대상의 역활(인터페이스)만 알면 됨
    - 공연에서 로미오 역활을 하는 사람이 줄리엣에 대해서 몰라도 되는것 처럼
- **클라이언트**는 구현 대상의 **내부 구조를 몰라도** 됨
    - 자동차가 막 어떻게 구현됬는지는 필요없는것처럼
- **클라이언트**는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않음
    - 기름차가 전기차가 된다해서 운전을 못하는게 아닌것처럼
- **클라이언트**는 구현 **대상 자체를 변경**해도 영향을 받지 않음
    - 내연기관에서 전기차가 됬을대 운전자를 변경해야되지 않는것처럼

### 자바 언어

- 자바 언어의 다형성을 활용
    - 역활 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 **역활**과 **구현**을 명확히 분리
- 객체 설계시 역활(인터페이스)을 먼저 부여하고, 그 역활을 수행하는 구현 객체 만들기
    - 일반 상속도 가능하지만 인터페이스는 다중으로 상속 구현이 가능하니까
    - 핵심은 구현보다 인터페이스가 먼저

## 객체의 협력이라는 관계부터 생각

- 우리가 다형성을 공부할 때 오해하는 것 중 하나
    - 다형성이라는게 부모가 있고 그걸 구현한거라는 개념까지만 본다는것
    - 중요한건 클라이언트가 있어야함
- 
- 혼자 있는 객체는 없다
    - 클라이언트: 요청
    - 서버: 응답
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다

### 예시

- 클라이언트 → 서버
- 클라이언트 → 서버 + 클라이언트 → 서버1, 서버2
    - 클라이언트가 서버가 될 수도 있음
- 여기서 응답이라는 개념은 데이터를 넣어서 리턴값이 꼭 없어도 됨
- 클라이언트가 요청하는 행위를 하는게 응답이라고 보면 됨

## 자바 언어의 다형성

- **오버라이딩** 을 떠올려 보자
    - 자바 언어가 다형성을 구현하는 방법
- 오버라이딩은 자바 기본 문법
- 오버라이딩 된 메소드가 실행
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다
    - 자바가 가진 다형성의 장점
- 물론 클래스 상속 관계도 다형성, 오버 라이딩 적용 가능
    - 

### 예시

- client: MemberService
    - MemberRepository 에 의존함
        - 의존한다는 의미는 해당 객체를 알고있음
- interface: MemberRepository
- 구현체: MemoryMemberRepository, JdbcMemberRepository
- 그런데 이 멤버 레포지토리에 구현체 객체들을 할당이 가능한가?

```java
public class MemberService { 
		private MemberRepository memberRepository = new MemoryMemberRepository();
		private MemberRepository memberRepository = new JdbcMemberRepository();
}
```

- 다형성이기 때문에 가능함
    - 부모 타입으로 다 받 을 수 있음

## 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 **실행 시점**에 **유연**하게 변경 할 수 있다
    - 
- 다형성의 본질을 이해하려면 **협력**이라는 객체 사이의 관계에서 시작해야함
    - 
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다**

## 역활과 구현을 분리 → 정리

- 실세계의 역활과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 유연하고 변경 용이
- 확장 가능한 설계
    - `memberRepository` 의 구현체를 무한히 확장 가능
- 클라이언트에 영향을 주지 않는 변경 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요
    - 제일 중요함
    - 인터페이스개 깨지면 끝남
    - save 말고 다른 메소드가 필요하면 다시 만들어야 하니까

## 역활과 구현을 분리 → 한계

- 역활(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생
- 자동차를 비행기로 변경해야 한다면?
    - 클라이언트 구현까지 모든것이 변경되어야함
- 대본 자체가 변경된다면?
- USB 인터페이스가 변경된다면?
- 인터페이스를 안정적으로 잘 설계하는것이 중요
    - 자바 뿐만이 아니라 모두 적용됨
    - 웹도 클라이언트 형식의 개발을 요즘 많이 함
        - front 만 독립적으로 돌도록
    - api 설계도 중요함
        - 최대한 클라이언트가 영향이 없도록

## 스프링과 객체 지향

- **다형성이 가장 중요**
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI) 은 다형성을 활용해서 역활과 구현을 편리하게 다룰 수 있도록 지원
- 스프링을 사용하면 마치 레고 블럭을 조립하듯, 공연 무대의 배우 선택을 하듯, 구현을 편리하게 변경 가능

# 좋은 객체 지향 설계의 5가지 원칙(SOLID)

## SOLID

<aside>
💡 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

</aside>

- 기존의 있던 개념을 용어를 정리해서 만듬

- SRP(Single Responsibility Principle): 단일 책임 원칙
- OCP(Open Closed Principsle): 개방 폐쇄 원칙
- LSP(Liskov Subsitution Principle): 리스코프 치환 원칙
- IPS(Interface segregation Principle): 인터페이스 분리 원칙
- DIP(Dependency Inversion Principle): 의존관계 역전 원칙

## SRP(Single Responsibility Principle): 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다
- **하나의 책임이라는 것은 모호하다**
    - 클 수도 작을 수도 있음
        - 범위를 너무 작게하면 객체가 너무 잘게 쪼개지고
        너무 크게 하면 책임이 너무 커짐
        - 적절하게 조절해줘야함
    - 문맥과 상황에 따라 다름
    - 이 부분은 경험이 필요함
- **중요한 기준은 변경**
    - 변경이 있을 때 파급 효과가 적으면 단일 책임의 원칙을 잘 따른것
    - UI 를 하나 변경하는데 모든 SQL 코드같은 여러 코드들도 다 변경해야된다면?
    - 
- 예) UI 변경, 객체의 생성과 사용을 분리

## OCP(Open Closed Principsle): 개방 폐쇄 원칙

- 소프트웨어 요소는 **확장에 열려**있으나 **변경에는 닫혀** 있어야 한다
- 이런 거짓말 같은 말이? 확장을 하려면, 당연히 기존 코드를 변경?
    - 기능이 확장될려면 코드가 변경이 필요한데?
    - 코드의 변경없이 기능을 확장?
- **다형성**을 활용해보자
    - 자바 언어의 다형성을 사용하면 가능
    - 우리가 봤었던 자동차, 공연 등등 예제를 떠올려보자
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 지금까지 배운 역활과 구현의 분리를 생각

## OCP(Open Closed Principsle): 문제점

- MemberService 클라이언트가 구현 클래스를 직접 선택
    - `private MemberRepository memberRepository = new MemoryMemberRepository();`
        - 기존
    - `private MemberRepository memberRepository = new JdbcMemberRepository();`
        - 변경
    - 우리가 잘 생각해보면 `MemoryMemberRepository` 를 잘 쓰다가 `JdbcMemberRepository` 로 변경하고 싶으면 기존 코드를 주석하고 새로운 Jdbc 코드를 넣어서 수정해줘야하는데???
- **구현 객체를 변경하려면 클라이언트 코드를 변경해야함**
- **분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다**
    - 구현까지는 가능하지만 적용하려면 OCP 원칙을 지킬 수 없음 → 클라이언트가 변경되어야함
- 이 문제를 해결할 방법은?
    - **객체를 생성하고, 연관 관계를 맻어주는 별도의 조립, 설정자가 필요**
    - 이것을 바로 스프링 컨테이너가 해줌
    - 이것을 가능하게 하기 위해서 DI IOC 가 들어가야함

## LSP(Liskov Subsitution Principle): 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면, 이 원칙이 필요함
- **단순히 컴파일에 성공하는 것을 넘어서는 이야기**
- 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함
    - 엑셀을 밟아서 마이너스가 된다고 해도 컴파일 오류는 아님
    - 엑셀이 앞으로 가라는 규약이 되어있으면 그 원칙을 지켜야 한다는 의미

## IPS(Interface segregation Principle): 인터페이스 분리 원칙

- **특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다**
    - 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
        - 만약 자동차 인터페이스 하나만 있다면? 하나의 인터페이스에 문제가 생겨서 변경할때 문제도 되고 기능이 복잡해짐
    - 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- **인터페이스가 명확해지고, 대체 가능성이 높아짐**
    - 대체 가능성: 덩어리가 크면 구현하기 어렵지만 덩어리가 작으면 구현하기 쉬워짐

## DIP(Dependency Inversion Principle): 의존관계 역전 원칙

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”
    - 의존성 주입은 이 원칙을 따르는 방법중 하나
    - 말만 들으면 이해가 안가긴 함
- 쉽게 말해서 구현 클래스에 의존하지 말고, **인터페이스에 의존**
    - `memberRepository` 는 인터페이스만 의존하라는 말
        - 리포지토리는 몰라야함
- 앞에서 이야기한 **역활에 의존하게 해야 한다는 것과 같다**.
- 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다!
- 구현체에 의존하게 되면 변경이 아주 어려워진다

## DIP(Dependency Inversion Principle): 문제점

- 그런데 OCP 에서 설명한 MemberService 는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존함
    - 코드를 보면 new 를 통한 구현 클래스도 의존하고있음
    - 의존한다는 것은 해당 클래스를 알아야 한다는거
    - 그렇다보니 jdbc 코드로 변경하려고 할 때 실제 코드를 변경하는것
- MemberService 클라이언트가 구현 클래스를 직접 선택
    - `memberRepository m = new **MemoryMemberRepository;**`
- **DIP 위반!**
    - 추상화에 의존해야지 구체화에 의존하면 안된다
- 그럼 어떻게 해야하는가?
    - MemberService 는 리포지토리 인터페이스에만 의존하도록 설계를 해야함

## 정리

- **객체 지향의 핵심은 다형성**
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없음
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경됨
- **다형성 만으로는 OCP DIP 를 지킬 수 없음**
- 뭔가 더 필요함
    - 다형성 만으로 클라이언트 코드의 변경을 막을 수 없음
    - 객체 지향을 잘 공부한 사람들은 여기까지 온다

# 객체 지향 설계와 스프링

## 다시 스프링으로

### 스프링 이야기에 왜 객체 지향 이야기가 나오는가?

- **스프링은 다음 기술로 다형성 + OCP, DIP 를 가능하게 지원**
    - DI(Dependency Injection): 의존관계, 의존성 주입
    - DI 컨테이너 제공
        - 자바 객체들을 어떤 컨테이너 안에 넣어놓고 이 안에서 의존관계를 서로 연결해주고 주입해주는 기능을 제공
- **클라이언트 코드의 변경 없이 기능 확장**
    - DI 가 가능해야 가능
- 쉽게 부품을 교체하듯이 개발

### 스프링이 없던 시절

- 옛날 어떤 개발자가 좋은 객체 지향 개발을 하려고 OCP DIP 원칙을 지키면서 개발을 하다보니 일이 너무 많았음
    - 배보다 배꼽이 큼
    - 그래서 프레임워크로 만들어 버림
- 순수하게 자바로 OCP DIP 원칙들을 지키면서 개발을 해보면, 결극 스프링 프레임워크를 만들게 됨
    - 정확히는 DI 컨테이너
- DI 개념은 말로 설명해도 이햐가 잘 안됨. 코드로 짜봐야 필요성을 알게됨
- 그러면 이제 스프링이 왜? 만들어졌는지 코드로 이해해보자